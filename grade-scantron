#! /usr/bin/env python3

from pytools import Record
import sys
import re

if sys.version_info < (3,):
    # Python 3 is needed because Python 3's CSV module handles Unicode.
    raise RuntimeError("need Python 3!")

from codecs import open

#from warnings import warn

import logging
logger = logging.getLogger(__name__)


class ScantronExam(Record):
    pass


def read_scantron_file(lines, options):
    for l in lines:
        if not l.strip():
            continue
        if len(l) == 1:
            continue
        if len(l) != 174:
            raise ValueError("invalid record length: %d" % len(l))

        yield ScantronExam(
            last_name=l[40:50].rstrip(),
            initial=l[50],
            university_id=l[51:60],
            section=l[60:63],
            network_id=l[63:71].lower().strip(),
            form_id=l[71],
            answers=l[72:168],
            )


def separate_out_keys(exams):
    scantron_keys = {}

    new_exams = []

    for s in exams:
        if (s.last_name.rstrip() == "KEY"
                and s.university_id.startswith("99999999")):
            if s.form_id in scantron_keys:
                raise ValueError("two keys for form id '%s'" % s.form_id)
            scantron_keys[s.form_id] = s
        else:
            new_exams.append(s)

    return new_exams, scantron_keys


def read_latex_key(name, inf, forms):
    version_re = re.compile("^version: (.+)$")
    problem_re = re.compile("^problem ([0-9]+): (.+)$")
    title_re = re.compile("^title ([0-9]+): (.+)$")

    lines = list(inf)

    version_match = version_re.match(lines[0])
    if version_match is None:
        raise RuntimeError("version line not found in '%s'" % name)
    form_id = version_match.group(1)
    lines = lines[1:]

    form = forms[form_id]
    for l in lines:
        problem_match = problem_re.match(l)
        title_match = title_re.match(l)

        if problem_match:
            problem_nr = int(problem_match.group(1))
            action = problem_match.group(2)

            if action == "dump":
                form.dump_problem(problem_nr)
            else:
                assert len(action) == 1
                answer = ord(action) - ord("A")

                form.add_correct_answer(problem_nr, answer)
        elif title_match:
            problem_nr = int(title_match.group(1))
            form.get_problem(problem_nr).title = title_match.group(2).strip()
        else:
            raise RuntimeError(
                "invalid line found in '%s': %s"
                % (name, l))

    if form.full_score is None:
        form.full_score = sum(
            1
            for p in form.problems.values()
            if p.correct_answers)


class Problem(Record):
    """
    .. attribute:: number
    .. attribute:: title
    .. attribute:: correct_answers

        set of correct answers as set of 0-based numbers

    .. attribute:: is_dumped
    """

    def __init__(self, number):
        Record.__init__(
            self,
            number=number,
            title="<no title>",
            correct_answers=set(),
            is_dumped=None)


class FormData(object):
    """
    .. attribute:: form_id
    .. attribute:: problems

        map problem nr to Problem instance
    .. attribute:: full_score
    """

    def __init__(self, form_id, full_score=None):
        self.form_id = form_id
        self.problems = {}
        self.full_score = full_score

    def get_problem(self, problem_nr):
        return self.problems.setdefault(problem_nr, Problem(number=problem_nr))

    def dump_problem(self, problem_nr):
        """
        :arg problem_nr: 1-based
        """

        self.get_problem(problem_nr).is_dumped = True

    def add_correct_answer(self, problem_nr, answer_nr):
        """
        :arg problem_nr: 1-based
        :arg answer_nr: 0-based
        """

        self.get_problem(problem_nr).correct_answers.add(answer_nr)


class GradeRecord(Record):
    """
    .. attribute:: exam
    .. attribute:: points
    .. attribute:: missed_problems
    .. attribute:: offset
    """


class MissedProblemRecord(Record):
    """
    .. attribute:: problem
    .. attribute:: your_answer
    """


def get_grade_rec(exam, form, options):
    grade_recs = {}

    for offset in options.try_offsets:
        points = options.bonus
        missed_problems = []

        for problem_nr, answer in enumerate(exam.answers):
            # make 1-based
            problem_nr += 1 + offset

            try:
                problem = form.problems[problem_nr]
            except KeyError:
                if answer != " " and not offset:
                    from warnings import warn
                    warn(
                        "student '%s' answered unknown problem "
                        "'%d' with '%s'" % (
                            exam.last_name,
                            problem_nr,
                            answer))

                continue

            if answer == " ":
                continue

            # make 0-based
            answer = int(answer) - 1
            assert 0 <= answer <= 4

            if problem.is_dumped:
                continue

            correct_answers = problem.correct_answers
            if answer in correct_answers:
                points += 1
            else:
                missed_problems.append(
                    MissedProblemRecord(
                        problem=problem,
                        your_answer=answer))

        grade_recs[offset] = GradeRecord(
            exam=exam,
            points=points,
            missed_problems=missed_problems,
            offset=offset,
            )

    from pytools import argmax2
    best_result = argmax2(
        (grade_rec, grade_rec.points)
        for grade_rec in grade_recs.values())

    if best_result.points > grade_recs[0].points:
        logger.info(
            "improved result with offset for %s: %d vs %d"
            % (exam.network_id, best_result.points, grade_recs[0].points))

    return best_result


def stringify_answer(answer):
    if answer is None:
        return "no answer"
    else:
        return chr(65+answer)


def shorten_title(title):
    if len(title) > 10:
        return title[:10]+u'\u2026'
    else:
        return title


def print_problem_analytics(forms, exams):
    for form_id in sorted(forms):
        print(75*"-")
        print("FORM %s" % form_id)
        print(75*"-")
        form = forms[form_id]
        for problem_nr in sorted(
                list(form.problems.keys())
                ):
            answer_freqs = {}
            total_answers = 0

            problem = form.problems[problem_nr]

            for e in exams:
                if e.form_id != form_id:
                    continue

                answer = e.answers[problem_nr-1]
                if answer == " ":
                    answer = None
                else:
                    answer = int(answer)-1
                    assert 0 <= answer <= 4
                    total_answers += 1

                answer_freqs[answer] = answer_freqs.get(answer, 0) + 1

            if problem.is_dumped:
                print("Form %s Question %d: UNGRADED" % (
                    form_id, problem_nr))
                continue

            if total_answers == 0:
                print("Form %s Question %d: NO ANSWERS (%s)" % (
                    form_id, problem_nr, problem.title))
                continue

            if problem.correct_answers:
                corr_str = ", ".join(
                    "%s: %2.0f%%=%d" % (
                        stringify_answer(answer),
                        100*answer_freqs.get(answer, 0)/total_answers,
                        answer_freqs.get(answer, 0))
                    for answer in problem.correct_answers)
            else:
                corr_str = "<no correct answers>"

            incorr_str = ", ".join(
                "%s: %2.0f%%=%d" % (
                    stringify_answer(answer),
                    100*answer_freqs.get(answer, 0)/total_answers,
                    answer_freqs.get(answer, 0))
                for answer in sorted(
                    answer_freqs,
                    key=lambda answer: answer_freqs[answer],
                    reverse=True)
                if answer not in problem.correct_answers)

            print("Form %s Question %d: [[ %s ]] %s (%s)" % (
                form_id, problem_nr, corr_str, incorr_str, problem.title))


def get_export_points_and_feedback(grade_rec, forms, options):
    points = grade_rec.points
    feedback_items = []

    feedback_items.append("Form %s" % grade_rec.exam.form_id)
    form = forms[grade_rec.exam.form_id]

    if grade_rec.missed_problems:
        feedback_items.append(
            "Incorrect: "
            + " - ".join(
                "P%d: %s (OK: %s - %s)"
                % (mpr.problem.number,
                    stringify_answer(mpr.your_answer),
                    "".join(
                        stringify_answer(ans)
                        for ans in mpr.problem.correct_answers),
                    shorten_title(mpr.problem.title))
                for mpr in grade_rec.missed_problems
                if mpr.problem.correct_answers)
            )
    else:
        feedback_items.append("All answers correct.")

    if options.cap and points > options.cap:
        feedback_items.append(
            "Achieved points: %d. Extra credit capped to: %d/%d."
            % (points, options.cap, form.full_score))
        points = options.cap

    if grade_rec.offset:
        feedback_items.append(
            "Offset was applied. Form Q1 -> Exam Q%d"
            % (1+grade_rec.offset))

    return points, feedback_items


def main():
    from optparse import OptionParser
    parser = OptionParser(usage="%prog [options] DAT_FILES")

    parser.add_option("--debug", action="store_true")
    parser.add_option(
        "--latex-key", help="Add a LaTeX-generated key data file",
        metavar="FILE", action="append")
    parser.add_option(
        "--bonus", help="Add free bonus points",
        metavar="POINTS", type=int, default=0)
    parser.add_option(
        "--full-score", help="Set full score for determining percentages",
        metavar="POINTS", type=int)
    parser.add_option(
        "--cap", help="Don't propagate more than this "
        "number of points to grade export",
        metavar="POINTS", type=int)
    parser.add_option(
        "--try-offsets", help="Try a few offsets for Scantron grading "
        "(should include 0)",
        metavar="OFFSET,OFFSET")

    parser.add_option("--print-grades", action="store_true")
    parser.add_option("--print-stats", action="store_true")
    parser.add_option("--print-problem-analytics", action="store_true")
    parser.add_option("--write-csv", metavar="FILE")
    parser.add_option("--print-student-report", metavar="NETWORK_ID")

    options, args = parser.parse_args()

    if not args:
        parser.print_help()
        sys.exit(1)

    if options.debug:
        logging.basicConfig(level=logging.INFO)

    if options.try_offsets is not None:
        options.try_offsets = [int(o) for o in options.try_offsets.split(",")]
        assert 0 in options.try_offsets
    else:
        options.try_offsets = [0]

    exams = []
    for arg in args:
        with open(arg, "rt") as inf:
            exams.extend(list(read_scantron_file(inf, options)))

    # {{{ figure out form versions

    form_ids = sorted(set(s.form_id for s in exams))
    logger.info("%d form versions found: %s" % (
        len(form_ids), form_ids))

    forms = dict(
        (form_id, FormData(form_id, full_score=options.full_score))
        for form_id in form_ids)

    # }}}

    # {{{ handle scantron keys

    exams, scantron_keys = separate_out_keys(exams)

    logger.info("%d scantron keys found: %s" % (
        len(scantron_keys), sorted(scantron_keys.keys())))

    # }}}

    # {{{ handle latex keys

    if options.latex_key is not None:
        for fn in options.latex_key:
            with open(fn, "rt") as inf:
                read_latex_key(fn, inf, forms)

        for form_id, key in scantron_keys.items():
            grade_rec = get_grade_rec(key, forms[key.form_id], options)
            logger.info("scantron key for form '%s' received %d points" % (
                form_id, grade_rec.points))

    # }}}

    if options.print_stats:
        point_counts = []
        form_point_counts = {}
        for e in exams:
            grade_rec = get_grade_rec(e, forms[e.form_id], options)
            point_counts.append(grade_rec.points)
            form_point_counts.setdefault(e.form_id, []) \
                .append(grade_rec.points)

        from pytools import string_histogram, average, std_deviation

        print(string_histogram(
            point_counts,
            min_value=0, max_value=(max(point_counts)), bin_count=15,
            width=30))

        print()
        print("Mean: %f" % (average(point_counts)))
        print("Std deviation: %f" % (std_deviation(point_counts, False)))
        print()
        for form_id in sorted(form_point_counts):
            print("Form %s mean: %f" % (
                form_id, average(form_point_counts[form_id])))

    if options.print_grades:
        for e in exams:
            form = forms[e.form_id]
            grade_rec = get_grade_rec(e, form, options)
            print("%-20s | %-10s | % 6.1f %% | % 3d points" % (
                e.last_name + ", " + e.initial, e.network_id,
                grade_rec.points/form.full_score*100, grade_rec.points))

    if options.print_problem_analytics:
        print_problem_analytics(forms, exams)

    if options.write_csv:
        import csv
        with open(options.write_csv, 'wb', encoding="utf-8") as csvfile:
            csvwriter = csv.writer(csvfile)
            csvwriter.writerow(
                ["NetID", "Last Name", "Initial", "Points", "Feedback"])

            for e in exams:
                grade_rec = get_grade_rec(e, forms[e.form_id], options)

                points, feedback_items = \
                    get_export_points_and_feedback(grade_rec, forms, options)

                csvwriter.writerow(
                    [e.network_id, e.last_name, e.initial,
                        points, u" * ".join(feedback_items)])

    if options.print_student_report:
        for e in exams:
            if e.network_id.lower() == options.print_student_report.lower():
                grade_rec = get_grade_rec(e, forms[e.form_id], options)

                points, feedback_items = \
                    get_export_points_and_feedback(grade_rec, forms, options)

                for fbi in feedback_items:
                    print(fbi)

                print()
                print("Name: %s, %s" % (e.last_name, e.initial))
                print("Points: %d" % points)

if __name__ == "__main__":
    main()
